"use strict";(self.webpackChunk_graphql_codegen_website=self.webpackChunk_graphql_codegen_website||[]).push([[7973],{58186:function(e,n,t){t.d(n,{jf:function(){return pn}});var i=t(83755),o=t(12640),s=t(79945),r=t(43903),l=t(57554),a=t(73798),c=t(82299),u=t(29936),d=t(5776),f=t(43165);const p=e=>Array.isArray(e)?e:e?[e]:[];function v(e,n){return!function(e,n){if(Array.isArray(e)&&Array.isArray(n)){if(e.length!==n.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==n[t])return!1;return!0}return e===n||!e&&!n}(e,n)}function T(e){var n,t;let i;return"alias"in e&&(i=null===(n=e.alias)||void 0===n?void 0:n.value),null==i&&"name"in e&&(i=null===(t=e.name)||void 0===t?void 0:t.value),null==i&&(i=e.kind),i}function E(e,n,t){const i=T(e),o=T(n);return"function"==typeof t?t(i,o):function(e,n){return String(e)<String(n)?-1:String(e)>String(n)?1:0}(i,o)}function m(e){return null!=e}function y(e,n=["directives"]){return n.reduce(((e,n)=>null==e?e:e[n]),null==e?void 0:e.extensions)}function N(e){if((0,i.zM)(e)){const n=N(e.ofType);if(n.kind===l.h.NON_NULL_TYPE)throw new Error(`Invalid type node ${JSON.stringify(e)}. Inner type of non-null type cannot be a non-null type.`);return{kind:l.h.NON_NULL_TYPE,type:n}}return(0,i.HG)(e)?{kind:l.h.LIST_TYPE,type:N(e.ofType)}:{kind:l.h.NAMED_TYPE,name:{kind:l.h.NAME,value:e.name}}}function I(e){if(null===e)return{kind:l.h.NULL};if(void 0===e)return null;if(Array.isArray(e)){const n=[];for(const t of e){const e=I(t);null!=e&&n.push(e)}return{kind:l.h.LIST,values:n}}if("object"==typeof e){const n=[];for(const t in e){const i=I(e[t]);i&&n.push({kind:l.h.OBJECT_FIELD,name:{kind:l.h.NAME,value:t},value:i})}return{kind:l.h.OBJECT,fields:n}}if("boolean"==typeof e)return{kind:l.h.BOOLEAN,value:e};if("number"==typeof e&&isFinite(e)){const n=String(e);return h.test(n)?{kind:l.h.INT,value:n}:{kind:l.h.FLOAT,value:n}}if("string"==typeof e)return{kind:l.h.STRING,value:e};throw new TypeError(`Cannot convert value to AST: ${e}.`)}const h=/^-?(?:0|[1-9][0-9]*)$/;function _(e,n={}){const t=n.pathToDirectivesInExtensions,o=e.getTypeMap(),r=function(e,n){var t,i;const o={query:void 0,mutation:void 0,subscription:void 0},s=[];null!=e.astNode&&s.push(e.astNode);if(null!=e.extensionASTNodes)for(const l of e.extensionASTNodes)s.push(l);for(const l of s)if(l.operationTypes)for(const e of l.operationTypes)o[e.operation]=e;const r={query:e.getQueryType(),mutation:e.getMutationType(),subscription:e.getSubscriptionType()};for(const d in o)null!=r[d]&&(null!=o[d]?o[d].type=N(r[d]):o[d]={kind:l.h.OPERATION_TYPE_DEFINITION,operation:d,type:N(r[d])});const a=Object.values(o).filter(m),c=g(e,e,n);if(!a.length&&!c.length)return null;const u={kind:null!=a?l.h.SCHEMA_DEFINITION:l.h.SCHEMA_EXTENSION,operationTypes:a,directives:c};return u.description=(null!==(i=null===(t=e.astNode)||void 0===t?void 0:t.description)&&void 0!==i?i:null!=e.description)?{kind:l.h.STRING,value:e.description,block:!0}:void 0,u}(e,t),u=null!=r?[r]:[],d=e.getDirectives();for(const i of d)(0,a.xg)(i)||u.push(O(i,e,t));for(const l in o){const n=o[l],r=(0,s.u1)(n),a=(0,c.s9)(n);if(!r&&!a)if((0,i.lp)(n))u.push(S(n,e,t));else if((0,i.oT)(n))u.push(b(n,e,t));else if((0,i.EN)(n))u.push(M(n,e,t));else if((0,i.hL)(n))u.push(F(n,e,t));else if((0,i.EM)(n))u.push(k(n,e,t));else{if(!(0,i.KA)(n))throw new Error(`Unknown type ${n}.`);u.push(R(n,e,t))}}return{kind:l.h.DOCUMENT,definitions:u}}function O(e,n,t){var i,o;return{kind:l.h.DIRECTIVE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description}:void 0,name:{kind:l.h.NAME,value:e.name},arguments:(null==e?void 0:e.args)?e.args.map((e=>D(e,n,t))):void 0,repeatable:e.isRepeatable,locations:(null==e?void 0:e.locations)?e.locations.map((e=>({kind:l.h.NAME,value:e}))):[]}}function g(e,n,t){const i=y(e,t);let o,s=[];if(null!=e.astNode&&s.push(e.astNode),"extensionASTNodes"in e&&null!=e.extensionASTNodes&&(s=s.concat(e.extensionASTNodes)),null!=i)o=P(n,i);else{o=[];for(const e of s)e.directives&&o.push(...e.directives)}return o}function A(e,n,t){var i,o;let s=[],r=null;const l=y(e,t);let c;return c=null!=l?P(n,l):null===(i=e.astNode)||void 0===i?void 0:i.directives,null!=c&&(s=c.filter((e=>"deprecated"!==e.name.value)),null!=e.deprecationReason&&(r=null===(o=c.filter((e=>"deprecated"===e.name.value)))||void 0===o?void 0:o[0])),null!=e.deprecationReason&&null==r&&(r=C("deprecated",{reason:e.deprecationReason},a.fg)),null==r?s:[r].concat(s)}function D(e,n,t){var i,o,s;return{kind:l.h.INPUT_VALUE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},type:N(e.type),defaultValue:void 0!==e.defaultValue&&null!==(s=(0,u.J)(e.defaultValue,e.type))&&void 0!==s?s:void 0,directives:A(e,n,t)}}function S(e,n,t){var i,o;return{kind:l.h.OBJECT_TYPE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},fields:Object.values(e.getFields()).map((e=>x(e,n,t))),interfaces:Object.values(e.getInterfaces()).map((e=>N(e))),directives:g(e,n,t)}}function b(e,n,t){var i,o;const s={kind:l.h.INTERFACE_TYPE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},fields:Object.values(e.getFields()).map((e=>x(e,n,t))),directives:g(e,n,t)};return"getInterfaces"in e&&(s.interfaces=Object.values(e.getInterfaces()).map((e=>N(e)))),s}function M(e,n,t){var i,o;return{kind:l.h.UNION_TYPE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},directives:g(e,n,t),types:e.getTypes().map((e=>N(e)))}}function F(e,n,t){var i,o;return{kind:l.h.INPUT_OBJECT_TYPE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},fields:Object.values(e.getFields()).map((e=>function(e,n,t){var i,o,s;return{kind:l.h.INPUT_VALUE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},type:N(e.type),directives:A(e,n,t),defaultValue:null!==(s=(0,u.J)(e.defaultValue,e.type))&&void 0!==s?s:void 0}}(e,n,t))),directives:g(e,n,t)}}function k(e,n,t){var i,o;return{kind:l.h.ENUM_TYPE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},values:Object.values(e.getValues()).map((e=>function(e,n,t){var i,o;return{kind:l.h.ENUM_VALUE_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},directives:g(e,n,t)}}(e,n,t))),directives:g(e,n,t)}}function R(e,n,t){var i,o,s,r;let a=[],c=null;const u=y(e,t);let d;d=null!=u?P(n,u):null===(i=e.astNode)||void 0===i?void 0:i.directives,null!=d&&(a=d.filter((e=>"specifiedBy"!==e.name.value)),null!=e.specifiedByUrl&&(c=null===(o=d.filter((e=>"specifiedBy"===e.name.value)))||void 0===o?void 0:o[0])),null!=e.specifiedByUrl&&null==c&&(c=C("specifiedBy",{url:e.specifiedByUrl}));const f=null==c?a:[c].concat(a);return{kind:l.h.SCALAR_TYPE_DEFINITION,description:null!==(r=null===(s=e.astNode)||void 0===s?void 0:s.description)&&void 0!==r?r:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},directives:f}}function x(e,n,t){var i,o;return{kind:l.h.FIELD_DEFINITION,description:null!==(o=null===(i=e.astNode)||void 0===i?void 0:i.description)&&void 0!==o?o:e.description?{kind:l.h.STRING,value:e.description,block:!0}:void 0,name:{kind:l.h.NAME,value:e.name},arguments:e.args.map((e=>D(e,n,t))),type:N(e.type),directives:A(e,n,t)}}function C(e,n,t){const i=[];if(null!=t)for(const o of t.args){const e=o.name,t=n[e];if(void 0!==t){const n=(0,u.J)(t,o.type);n&&i.push({kind:l.h.ARGUMENT,name:{kind:l.h.NAME,value:e},value:n})}}else for(const o in n){const e=I(n[o]);e&&i.push({kind:l.h.ARGUMENT,name:{kind:l.h.NAME,value:o},value:e})}return{kind:l.h.DIRECTIVE,name:{kind:l.h.NAME,value:e},arguments:i}}function P(e,n){const t=[];for(const i in n){const o=n[i],s=null==e?void 0:e.getDirective(i);if(Array.isArray(o))for(const e of o)t.push(C(i,e,s));else t.push(C(i,o,s))}return t}let U=globalThis.AggregateError;if(void 0===U){class e extends Error{constructor(n,t=""){super(t),this.errors=n,this.name="AggregateError",Error.captureStackTrace(this,e)}}U=function(n,t){return new e(n,t)}}new Map;var w;function L(e,n){if(n){const t=e[n.name];if((0,i.lp)(t))return t}}function Y(e,n){const t=Object.create(null);for(const i in e)t[i]=e[i];const o=Object.create(null);for(const i in t){const e=t[i];if(null==e||i.startsWith("__"))continue;const n=e.name;if(!n.startsWith("__")){if(null!=o[n])throw new Error(`Duplicate schema type name ${n}`);o[n]=e}}for(const i in o)o[i]=c(o[i]);const r=n.map((e=>function(e){if((0,a.xg)(e))return e;const n=e.toConfig();return n.args=l(n.args),new a.NZ(n)}(e)));return{typeMap:o,directives:r};function l(e){const n={};for(const t in e){const i=e[t],o=f(i.type);null!=o&&(i.type=o,n[t]=i)}return n}function c(e){if((0,i.lp)(e)){const n=e.toConfig(),t={...n,fields:()=>u(n.fields),interfaces:()=>d(n.interfaces)};return new i.h6(t)}if((0,i.oT)(e)){const n=e.toConfig(),t={...n,fields:()=>u(n.fields)};return"interfaces"in t&&(t.interfaces=()=>d(n.interfaces)),new i.oW(t)}if((0,i.EN)(e)){const n=e.toConfig(),t={...n,types:()=>d(n.types)};return new i.Gp(t)}if((0,i.hL)(e)){const n=e.toConfig(),t={...n,fields:()=>function(e){const n={};for(const t in e){const i=e[t],o=f(i.type);null!=o&&(i.type=o,n[t]=i)}return n}(n.fields)};return new i.sR(t)}if((0,i.EM)(e)){const n=e.toConfig();return new i.mR(n)}if((0,i.KA)(e)){if((0,s.u1)(e))return e;const n=e.toConfig();return new i.n2(n)}throw new Error(`Unexpected schema type: ${e}`)}function u(e){const n={};for(const t in e){const i=e[t],o=f(i.type);null!=o&&i.args&&(i.type=o,i.args=l(i.args),n[t]=i)}return n}function d(e){const n=[];for(const t of e){const e=f(t);null!=e&&n.push(e)}return n}function f(e){if((0,i.HG)(e)){const n=f(e.ofType);return null!=n?new i.p2(n):null}if((0,i.zM)(e)){const n=f(e.ofType);return null!=n?new i.bM(n):null}if((0,i.Zs)(e)){let n=t[e.name];return void 0===n&&(n=function(e){if("getFields"in e){const n=e.getFields();for(const e in n)return"_fake"===n[e].name}return!1}(e)?function(e){switch(e.name){case s._o.name:return s._o;case s.av.name:return s.av;case s.kH.name:return s.kH;case s.EZ.name:return s.EZ;case s.km.name:return s.km;default:return e}}(e):c(e),o[n.name]=t[e.name]=n),null!=n?o[n.name]:null}return null}}function j(e,n,t=null,o=null){if(null==n)return n;const s=(0,i.tf)(e);if((0,i.UT)(s))return null!=t?t(s,n):n;if((0,i.HG)(s))return n.map((e=>j(s.ofType,e,t,o)));if((0,i.hL)(s)){const e=s.getFields(),i={};for(const s in n){const r=e[s];null!=r&&(i[s]=j(r.type,n[s],t,o))}return null!=o?o(s,i):i}}function B(e,n){return j(e,n,((e,n)=>e.serialize(n)))}function V(e,n){return j(e,n,((e,n)=>e.parseValue(n)))}function $(e,n={}){const t=H(W(K(J(function(e,n,t){const o=function(e){const n=e[w.ENUM_VALUE];return null!=n?n:null}(t);if(!o)return e;return K(e,n,{[w.ENUM_TYPE]:e=>{const t=e.toConfig(),s=t.values,r={};for(const i in s){const t=s[i],l=o(t,e.name,n,i);if(void 0===l)r[i]=t;else if(Array.isArray(l)){const[e,n]=l;r[e]=void 0===n?t:n}else null!==l&&(r[i]=l)}return Z(new i.mR({...t,values:r}))}},(e=>(0,i.EM)(e)))}(K(J(e.getTypeMap(),e,B),e,n,(e=>(0,i.UT)(e))),e,n),e,V),e,n,(e=>!(0,i.UT)(e))),e,n),e,n),s=function(e,n,t){const i=function(e){const n=e[w.DIRECTIVE];return null!=n?n:null}(t);if(null==i)return e.slice();const o=[];for(const s of e){const e=i(s,n);void 0===e?o.push(s):null!==e&&o.push(e)}return o}(e.getDirectives(),e,n),{typeMap:r,directives:l}=Y(t,s);return new o.XO({...e.toConfig(),query:L(r,L(t,e.getQueryType())),mutation:L(r,L(t,e.getMutationType())),subscription:L(r,L(t,e.getSubscriptionType())),types:Object.values(r),directives:l})}function K(e,n,t,i=(()=>!0)){const o={};for(const s in e)if(!s.startsWith("__")){const r=e[s];if(null==r||!i(r)){o[s]=r;continue}const l=Q(n,t,s);if(null==l){o[s]=r;continue}const a=l(r,n);if(void 0===a){o[s]=r;continue}o[s]=a}return o}function J(e,n,t){const i=H(e,n,{[w.ARGUMENT]:n=>{if(void 0===n.defaultValue)return n;const i=G(e,n.type);return null!=i?{...n,defaultValue:t(i,n.defaultValue)}:void 0}});return W(i,n,{[w.INPUT_OBJECT_FIELD]:e=>{if(void 0===e.defaultValue)return e;const n=G(i,e.type);return null!=n?{...e,defaultValue:t(n,e.defaultValue)}:void 0}})}function G(e,n){if((0,i.HG)(n)){const t=G(e,n.ofType);return null!=t?new i.p2(t):null}if((0,i.zM)(n)){const t=G(e,n.ofType);return null!=t?new i.bM(t):null}if((0,i.Zs)(n)){const t=e[n.name];return null!=t?t:null}return null}function W(e,n,t){const o={};for(const s in e)if(!s.startsWith("__")){const r=e[s];if(!(0,i.lp)(r)&&!(0,i.oT)(r)&&!(0,i.hL)(r)){o[s]=r;continue}const l=q(n,t,s);if(null==l){o[s]=r;continue}const a=r.toConfig(),c=a.fields,u={};for(const e in c){const t=c[e],i=l(t,e,s,n);if(void 0===i)u[e]=t;else if(Array.isArray(i)){const[e,n]=i;null!=n.astNode&&(n.astNode={...n.astNode,name:{...n.astNode.name,value:e}}),u[e]=void 0===n?t:n}else null!==i&&(u[e]=i)}(0,i.lp)(r)?o[s]=Z(new i.h6({...a,fields:u})):(0,i.oT)(r)?o[s]=Z(new i.oW({...a,fields:u})):o[s]=Z(new i.sR({...a,fields:u}))}return o}function H(e,n,t){const o={};for(const s in e)if(!s.startsWith("__")){const r=e[s];if(!(0,i.lp)(r)&&!(0,i.oT)(r)){o[s]=r;continue}const l=X(t);if(null==l){o[s]=r;continue}const a=r.toConfig(),c=a.fields,u={};for(const e in c){const t=c[e],i=t.args;if(null==i){u[e]=t;continue}const o=Object.keys(i);if(!o.length){u[e]=t;continue}const r={};for(const a of o){const t=i[a],o=l(t,e,s,n);if(void 0===o)r[a]=t;else if(Array.isArray(o)){const[e,n]=o;r[e]=n}else null!==o&&(r[a]=o)}u[e]={...t,args:r}}(0,i.lp)(r)?o[s]=new i.h6({...a,fields:u}):(0,i.oT)(r)?o[s]=new i.oW({...a,fields:u}):o[s]=new i.sR({...a,fields:u})}return o}function Q(e,n,t){let o;const s=[...function(e,n){var t,o,s;const r=e.getType(n),l=[w.TYPE];return(0,i.lp)(r)?(l.push(w.COMPOSITE_TYPE,w.OBJECT_TYPE),n===(null===(t=e.getQueryType())||void 0===t?void 0:t.name)?l.push(w.ROOT_OBJECT,w.QUERY):n===(null===(o=e.getMutationType())||void 0===o?void 0:o.name)?l.push(w.ROOT_OBJECT,w.MUTATION):n===(null===(s=e.getSubscriptionType())||void 0===s?void 0:s.name)&&l.push(w.ROOT_OBJECT,w.SUBSCRIPTION)):(0,i.hL)(r)?l.push(w.INPUT_OBJECT_TYPE):(0,i.oT)(r)?l.push(w.COMPOSITE_TYPE,w.ABSTRACT_TYPE,w.INTERFACE_TYPE):(0,i.EN)(r)?l.push(w.COMPOSITE_TYPE,w.ABSTRACT_TYPE,w.UNION_TYPE):(0,i.EM)(r)?l.push(w.ENUM_TYPE):(0,i.KA)(r)&&l.push(w.SCALAR_TYPE),l}(e,t)];for(;!o&&s.length>0;){o=n[s.pop()]}return null!=o?o:null}function q(e,n,t){let o;const s=[...function(e,n){var t,o,s;const r=e.getType(n),l=[w.FIELD];return(0,i.lp)(r)?(l.push(w.COMPOSITE_FIELD,w.OBJECT_FIELD),n===(null===(t=e.getQueryType())||void 0===t?void 0:t.name)?l.push(w.ROOT_FIELD,w.QUERY_ROOT_FIELD):n===(null===(o=e.getMutationType())||void 0===o?void 0:o.name)?l.push(w.ROOT_FIELD,w.MUTATION_ROOT_FIELD):n===(null===(s=e.getSubscriptionType())||void 0===s?void 0:s.name)&&l.push(w.ROOT_FIELD,w.SUBSCRIPTION_ROOT_FIELD)):(0,i.oT)(r)?l.push(w.COMPOSITE_FIELD,w.INTERFACE_FIELD):(0,i.hL)(r)&&l.push(w.INPUT_OBJECT_FIELD),l}(e,t)];for(;!o&&s.length>0;){o=n[s.pop()]}return null!=o?o:null}function X(e){const n=e[w.ARGUMENT];return null!=n?n:null}function Z(e){if((0,i.lp)(e)){const n=e.toConfig();if(null!=n.astNode){const e=[];for(const t in n.fields){const i=n.fields[t];null!=i.astNode&&e.push(i.astNode)}n.astNode={...n.astNode,kind:l.h.OBJECT_TYPE_DEFINITION,fields:e}}return null!=n.extensionASTNodes&&(n.extensionASTNodes=n.extensionASTNodes.map((e=>({...e,kind:l.h.OBJECT_TYPE_EXTENSION,fields:void 0})))),new i.h6(n)}if((0,i.oT)(e)){const n=e.toConfig();if(null!=n.astNode){const e=[];for(const t in n.fields){const i=n.fields[t];null!=i.astNode&&e.push(i.astNode)}n.astNode={...n.astNode,kind:l.h.INTERFACE_TYPE_DEFINITION,fields:e}}return null!=n.extensionASTNodes&&(n.extensionASTNodes=n.extensionASTNodes.map((e=>({...e,kind:l.h.INTERFACE_TYPE_EXTENSION,fields:void 0})))),new i.oW(n)}if((0,i.hL)(e)){const n=e.toConfig();if(null!=n.astNode){const e=[];for(const t in n.fields){const i=n.fields[t];null!=i.astNode&&e.push(i.astNode)}n.astNode={...n.astNode,kind:l.h.INPUT_OBJECT_TYPE_DEFINITION,fields:e}}return null!=n.extensionASTNodes&&(n.extensionASTNodes=n.extensionASTNodes.map((e=>({...e,kind:l.h.INPUT_OBJECT_TYPE_EXTENSION,fields:void 0})))),new i.sR(n)}if((0,i.EM)(e)){const n=e.toConfig();if(null!=n.astNode){const e=[];for(const t in n.values){const i=n.values[t];null!=i.astNode&&e.push(i.astNode)}n.astNode={...n.astNode,values:e}}return null!=n.extensionASTNodes&&(n.extensionASTNodes=n.extensionASTNodes.map((e=>({...e,values:void 0})))),new i.mR(n)}return e}function z(e){return function(e,n){const t=Object.create(null);for(const i in e){const n=e[i];if(null==n||i.startsWith("__"))continue;const o=n.name;if(!o.startsWith("__")){if(o in t)throw new Error(`Duplicate schema type name ${o}`);t[o]=n}}for(const i in t){const n=t[i];e[i]=n}for(const i of n)i.args=i.args.filter((e=>(e.type=c(e.type),null!==e.type)));for(const i in e){const n=e[i];!i.startsWith("__")&&i in t&&null!=n&&o(n)}for(const i in e)i.startsWith("__")||i in t||delete e[i];function o(e){if((0,i.lp)(e))return s(e),void r(e);if((0,i.oT)(e))return s(e),void("getInterfaces"in e&&r(e));if((0,i.EN)(e))a(e);else if((0,i.hL)(e))l(e);else if(!(0,i.UT)(e))throw new Error(`Unexpected schema type: ${e}`)}function s(e){const n=e.getFields();for(const[t,i]of Object.entries(n))i.args.map((e=>(e.type=c(e.type),null===e.type?null:e))).filter(Boolean),i.type=c(i.type),null===i.type&&delete n[t]}function r(e){if("getInterfaces"in e){const n=e.getInterfaces();n.push(...n.splice(0).map((e=>c(e))).filter(Boolean))}}function l(e){const n=e.getFields();for(const[t,i]of Object.entries(n))i.type=c(i.type),null===i.type&&delete n[t]}function a(e){const n=e.getTypes();n.push(...n.splice(0).map((e=>c(e))).filter(Boolean))}function c(n){if((0,i.HG)(n)){const e=c(n.ofType);return null!=e?new i.p2(e):null}if((0,i.zM)(n)){const e=c(n.ofType);return null!=e?new i.bM(e):null}if((0,i.Zs)(n)){const t=e[n.name];if(t&&n!==t)return t}return n}}(e.getTypeMap(),e.getDirectives()),e}function ee(e){var n,t;const o=Object.create({}),r=e.getTypeMap();for(const l in r)if(!l.startsWith("__")){const e=r[l];if((0,i.KA)(e)){if(!(0,s.u1)(e)){const n=e.toConfig();delete n.astNode,o[l]=new i.n2(n)}}else if((0,i.EM)(e)){o[l]={};const n=e.getValues();for(const e of n)o[l][e.name]=e.value}else if((0,i.oT)(e))null!=e.resolveType&&(o[l]={__resolveType:e.resolveType});else if((0,i.EN)(e))null!=e.resolveType&&(o[l]={__resolveType:e.resolveType});else if((0,i.lp)(e)){o[l]={},null!=e.isTypeOf&&(o[l].__isTypeOf=e.isTypeOf);const i=e.getFields();for(const e in i){const s=i[e];null!=s.subscribe&&(o[l][e]=o[l][e]||{},o[l][e].subscribe=s.subscribe),null!=s.resolve&&"defaultFieldResolver"!==(null===(n=s.resolve)||void 0===n?void 0:n.name)&&"defaultMergedResolver"!==(null===(t=s.resolve)||void 0===t?void 0:t.name)&&(o[l][e]=o[l][e]||{},o[l][e].resolve=s.resolve)}}}return o}function ne(e,n){const t=e.getTypeMap();for(const o in t){const e=t[o];if(!(0,i.xC)(e).name.startsWith("__")&&(0,i.lp)(e)){const t=e.getFields();for(const e in t){n(t[e],o,e)}}}}function te(e,n){const t=e.getTypeMap();for(const o in t){const e=t[o];if(!(0,i.xC)(e).name.startsWith("__"))if((0,i.lp)(e)){const t=e.getFields();for(const e in t){const i=t[e];for(const e of i.args)e.defaultValue=n(e.type,e.defaultValue)}}else if((0,i.hL)(e)){const t=e.getFields();for(const e in t){const i=t[e];i.defaultValue=n(i.type,i.defaultValue)}}}}function ie(e,n={}){const t={schema:e,unusedTypes:Object.create(null),implementations:Object.create(null)};for(const i in e.getTypeMap()){const n=e.getType(i);if(n&&"getInterfaces"in n)for(const e of n.getInterfaces()){null==se(t,e)&&(t.implementations[e.name]=Object.create(null)),t.implementations[e.name][n.name]=!0}}return function(e,n){for(const i in n.getTypeMap())i.startsWith("__")||(e.unusedTypes[i]=!0);const t=Object.create(null),o=function(e){const n=new Set,t=e.getQueryType(),i=e.getMutationType(),o=e.getSubscriptionType();for(const s of[t,i,o])s&&n.add(s);return n}(n);for(const i of o)oe(t,e,i);for(const s of n.getDirectives())for(const n of s.args){re(t,e,(0,i.xC)(n.type))}}(t,e),$(e,{[w.TYPE]:e=>{if(n.skipPruning&&n.skipPruning(e))return e;if((0,i.lp)(e)||(0,i.hL)(e)){if(!Object.keys(e.getFields()).length&&!n.skipEmptyCompositeTypePruning||t.unusedTypes[e.name]&&!n.skipUnusedTypesPruning)return null}else if((0,i.EN)(e)){if(!e.getTypes().length&&!n.skipEmptyUnionPruning||t.unusedTypes[e.name]&&!n.skipUnusedTypesPruning)return null}else if((0,i.oT)(e)){const i=se(t,e);if(!Object.keys(e.getFields()).length&&!n.skipEmptyCompositeTypePruning||i&&!Object.keys(i).length&&!n.skipUnimplementedInterfacesPruning||t.unusedTypes[e.name]&&!n.skipUnusedTypesPruning)return null}else if(t.unusedTypes[e.name]&&!n.skipUnusedTypesPruning)return null}})}function oe(e,n,t){if(!e[t.name])if(e[t.name]=!0,n.unusedTypes[t.name]=!1,(0,i.lp)(t)||(0,i.oT)(t)){const o=t.getFields();for(const t in o){const s=o[t];oe(e,n,(0,i.xC)(s.type));for(const t of s.args){re(e,n,(0,i.xC)(t.type))}}if((0,i.oT)(t)){const i=se(n,t);if(i)for(const t in i)oe(e,n,n.schema.getType(t))}if("getInterfaces"in t)for(const i of t.getInterfaces())oe(e,n,i)}else if((0,i.EN)(t)){const i=t.getTypes();for(const t of i)oe(e,n,t)}}function se(e,n){return e.implementations[n.name]}function re(e,n,t){if(!e[t.name]&&(n.unusedTypes[t.name]=!1,e[t.name]=!0,(0,i.hL)(t))){const o=t.getFields();for(const t in o){const s=o[t];re(e,n,(0,i.xC)(s.type))}}}function le(e,n=!1){const t=e[0]||{},i={};n&&Object.setPrototypeOf(i,Object.create(Object.getPrototypeOf(t)));for(const o of e)if(ae(t)&&ae(o)){if(n){const e=Object.getPrototypeOf(i),n=Object.getPrototypeOf(o);if(n)for(const t of Object.getOwnPropertyNames(n)){const i=Object.getOwnPropertyDescriptor(n,t);m(i)&&Object.defineProperty(e,t,i)}}for(const e in o)ae(o[e])?e in i?i[e]=le([i[e],o[e]],n):Object.assign(i,{[e]:o[e]}):Object.assign(i,{[e]:o[e]})}return i}function ae(e){return e&&"object"==typeof e&&!Array.isArray(e)}!function(e){e.TYPE="MapperKind.TYPE",e.SCALAR_TYPE="MapperKind.SCALAR_TYPE",e.ENUM_TYPE="MapperKind.ENUM_TYPE",e.COMPOSITE_TYPE="MapperKind.COMPOSITE_TYPE",e.OBJECT_TYPE="MapperKind.OBJECT_TYPE",e.INPUT_OBJECT_TYPE="MapperKind.INPUT_OBJECT_TYPE",e.ABSTRACT_TYPE="MapperKind.ABSTRACT_TYPE",e.UNION_TYPE="MapperKind.UNION_TYPE",e.INTERFACE_TYPE="MapperKind.INTERFACE_TYPE",e.ROOT_OBJECT="MapperKind.ROOT_OBJECT",e.QUERY="MapperKind.QUERY",e.MUTATION="MapperKind.MUTATION",e.SUBSCRIPTION="MapperKind.SUBSCRIPTION",e.DIRECTIVE="MapperKind.DIRECTIVE",e.FIELD="MapperKind.FIELD",e.COMPOSITE_FIELD="MapperKind.COMPOSITE_FIELD",e.OBJECT_FIELD="MapperKind.OBJECT_FIELD",e.ROOT_FIELD="MapperKind.ROOT_FIELD",e.QUERY_ROOT_FIELD="MapperKind.QUERY_ROOT_FIELD",e.MUTATION_ROOT_FIELD="MapperKind.MUTATION_ROOT_FIELD",e.SUBSCRIPTION_ROOT_FIELD="MapperKind.SUBSCRIPTION_ROOT_FIELD",e.INTERFACE_FIELD="MapperKind.INTERFACE_FIELD",e.INPUT_OBJECT_FIELD="MapperKind.INPUT_OBJECT_FIELD",e.ARGUMENT="MapperKind.ARGUMENT",e.ENUM_VALUE="MapperKind.ENUM_VALUE"}(w||(w={}));let ce={};function ue(){ce={}}function de(e){var n;const t=null===(n=e.name)||void 0===n?void 0:n.value;if(null!=t)switch(fe(e,t),e.kind){case"EnumTypeDefinition":if(e.values)for(const n of e.values)fe(n,t,n.name.value);break;case"ObjectTypeDefinition":case"InputObjectTypeDefinition":case"InterfaceTypeDefinition":if(e.fields)for(const n of e.fields)if(fe(n,t,n.name.value),he(n)&&n.arguments)for(const e of n.arguments)fe(e,t,n.name.value,e.name.value)}}function fe(e,n,t,i){const o=(0,d.Eb)(e,{commentDescriptions:!0});if("string"!=typeof o||0===o.length)return;const s=[n];t&&(s.push(t),i&&s.push(i));const r=s.join(".");ce[r]||(ce[r]=[]),ce[r].push(o)}function pe(e){return"\n# "+e.replace(/\n/g,"\n# ")}function ve(e,n){return e?e.filter((e=>e)).join(n||""):""}function Te(e){var n;return null!==(n=null==e?void 0:e.some((e=>e.includes("\n"))))&&void 0!==n&&n}function Ee(e){return e&&`  ${e.replace(/\n/g,"\n  ")}`}function me(e){return e&&0!==e.length?`{\n${Ee(ve(e,"\n"))}\n}`:""}function ye(e,n,t){return n?e+n+(t||""):""}const Ne={Name:{leave:e=>e.value},Variable:{leave:e=>"$"+e.name},Document:{leave:e=>ve(e.definitions,"\n\n")},OperationDefinition:{leave:e=>{const n=ye("(",ve(e.variableDefinitions,", "),")");return ve([e.operation,ve([e.name,n]),ve(e.directives," ")]," ")+" "+e.selectionSet}},VariableDefinition:{leave:({variable:e,type:n,defaultValue:t,directives:i})=>e+": "+n+ye(" = ",t)+ye(" ",ve(i," "))},SelectionSet:{leave:({selections:e})=>me(e)},Field:{leave({alias:e,name:n,arguments:t,directives:i,selectionSet:o}){const s=ye("",e,": ")+n;let r=s+ye("(",ve(t,", "),")");return r.length>80&&(r=s+ye("(\n",Ee(ve(t,"\n")),"\n)")),ve([r,ve(i," "),o]," ")}},Argument:{leave:({name:e,value:n})=>e+": "+n},FragmentSpread:{leave:({name:e,directives:n})=>"..."+e+ye(" ",ve(n," "))},InlineFragment:{leave:({typeCondition:e,directives:n,selectionSet:t})=>ve(["...",ye("on ",e),ve(n," "),t]," ")},FragmentDefinition:{leave:({name:e,typeCondition:n,variableDefinitions:t,directives:i,selectionSet:o})=>`fragment ${e}${ye("(",ve(t,", "),")")} on ${n} ${ye("",ve(i," ")," ")}`+o},IntValue:{leave:({value:e})=>e},FloatValue:{leave:({value:e})=>e},StringValue:{leave:({value:e,block:n})=>n?function(e,n=!1){const t=e.replace(/"""/g,'\\"""');return" "!==e[0]&&"\t"!==e[0]||-1!==e.indexOf("\n")?`"""\n${n?t:Ee(t)}\n"""`:`"""${t.replace(/"$/,'"\n')}"""`}(e):JSON.stringify(e)},BooleanValue:{leave:({value:e})=>e?"true":"false"},NullValue:{leave:()=>"null"},EnumValue:{leave:({value:e})=>e},ListValue:{leave:({values:e})=>"["+ve(e,", ")+"]"},ObjectValue:{leave:({fields:e})=>"{"+ve(e,", ")+"}"},ObjectField:{leave:({name:e,value:n})=>e+": "+n},Directive:{leave:({name:e,arguments:n})=>"@"+e+ye("(",ve(n,", "),")")},NamedType:{leave:({name:e})=>e},ListType:{leave:({type:e})=>"["+e+"]"},NonNullType:{leave:({type:e})=>e+"!"},SchemaDefinition:{leave:({description:e,directives:n,operationTypes:t})=>ye("",e,"\n")+ve(["schema",ve(n," "),me(t)]," ")},OperationTypeDefinition:{leave:({operation:e,type:n})=>e+": "+n},ScalarTypeDefinition:{leave:({description:e,name:n,directives:t})=>ye("",e,"\n")+ve(["scalar",n,ve(t," ")]," ")},ObjectTypeDefinition:{leave:({description:e,name:n,interfaces:t,directives:i,fields:o})=>ye("",e,"\n")+ve(["type",n,ye("implements ",ve(t," & ")),ve(i," "),me(o)]," ")},FieldDefinition:{leave:({description:e,name:n,arguments:t,type:i,directives:o})=>ye("",e,"\n")+n+(Te(t)?ye("(\n",Ee(ve(t,"\n")),"\n)"):ye("(",ve(t,", "),")"))+": "+i+ye(" ",ve(o," "))},InputValueDefinition:{leave:({description:e,name:n,type:t,defaultValue:i,directives:o})=>ye("",e,"\n")+ve([n+": "+t,ye("= ",i),ve(o," ")]," ")},InterfaceTypeDefinition:{leave:({description:e,name:n,interfaces:t,directives:i,fields:o})=>ye("",e,"\n")+ve(["interface",n,ye("implements ",ve(t," & ")),ve(i," "),me(o)]," ")},UnionTypeDefinition:{leave:({description:e,name:n,directives:t,types:i})=>ye("",e,"\n")+ve(["union",n,ve(t," "),ye("= ",ve(i," | "))]," ")},EnumTypeDefinition:{leave:({description:e,name:n,directives:t,values:i})=>ye("",e,"\n")+ve(["enum",n,ve(t," "),me(i)]," ")},EnumValueDefinition:{leave:({description:e,name:n,directives:t})=>ye("",e,"\n")+ve([n,ve(t," ")]," ")},InputObjectTypeDefinition:{leave:({description:e,name:n,directives:t,fields:i})=>ye("",e,"\n")+ve(["input",n,ve(t," "),me(i)]," ")},DirectiveDefinition:{leave:({description:e,name:n,arguments:t,repeatable:i,locations:o})=>ye("",e,"\n")+"directive @"+n+(Te(t)?ye("(\n",Ee(ve(t,"\n")),"\n)"):ye("(",ve(t,", "),")"))+(i?" repeatable":"")+" on "+ve(o," | ")},SchemaExtension:{leave:({directives:e,operationTypes:n})=>ve(["extend schema",ve(e," "),me(n)]," ")},ScalarTypeExtension:{leave:({name:e,directives:n})=>ve(["extend scalar",e,ve(n," ")]," ")},ObjectTypeExtension:{leave:({name:e,interfaces:n,directives:t,fields:i})=>ve(["extend type",e,ye("implements ",ve(n," & ")),ve(t," "),me(i)]," ")},InterfaceTypeExtension:{leave:({name:e,interfaces:n,directives:t,fields:i})=>ve(["extend interface",e,ye("implements ",ve(n," & ")),ve(t," "),me(i)]," ")},UnionTypeExtension:{leave:({name:e,directives:n,types:t})=>ve(["extend union",e,ve(n," "),ye("= ",ve(t," | "))]," ")},EnumTypeExtension:{leave:({name:e,directives:n,values:t})=>ve(["extend enum",e,ve(n," "),me(t)]," ")},InputObjectTypeExtension:{leave:({name:e,directives:n,fields:t})=>ve(["extend input",e,ve(n," "),me(t)]," ")}},Ie=Object.keys(Ne).reduce(((e,n)=>{return{...e,[n]:{leave:(t=Ne[n].leave,(e,n,i,o,s)=>{var r;const l=[],a=o.reduce(((e,n)=>(["fields","arguments","values"].includes(n)&&e.name&&l.push(e.name.value),e[n])),s[0]),c=[...l,null===(r=null==a?void 0:a.name)||void 0===r?void 0:r.value].filter(Boolean).join("."),u=[];return e.kind.includes("Definition")&&ce[c]&&u.push(...ce[c]),ve([...u.map(pe),e.description,t(e)],"\n")})}};var t}),{});function he(e){return"FieldDefinition"===e.kind}var _e,Oe=t(33277),ge=t(23476),Ae=t(65449),De=t(14734);function Se(e,n){if(!e||Array.isArray(e)&&0===e.length)return{};if(!Array.isArray(e))return e;if(1===e.length)return e[0]||{};const t=new Array;for(let o of e)Array.isArray(o)&&(o=Se(o)),"object"==typeof o&&o&&t.push(o);const i=le(t,!0);if(null==n?void 0:n.exclusions)for(const o of n.exclusions){const[e,n]=o.split(".");n&&"*"!==n?i[e]&&delete i[e][n]:delete i[e]}return i}function be(e,n,t){const i=[...n,...e].filter(m).reduce(((e,n)=>e.find((e=>e.name.value===n.name.value))?e:e.concat([n])),[]);return t&&t.sort&&i.sort(E),i}function Me(e,n){return!!e.find((e=>e.name.value===n.name.value))}function Fe(e,n){const t=[...n];for(const i of e){const e=t.findIndex((e=>e.name.value===i.name.value));if(e>-1){const n=t[e];if("ListValue"===n.value.kind){const e=n.value.values,t=i.value.values;n.value.values=xe(e,t,((e,n)=>{const t=e.value;return!t||!n.some((e=>e.value===t))}))}else n.value=i.value}else t.push(i)}return t}function ke(e=[],n=[],t){const i=t&&t.reverseDirectives,o=i?n:e,s=[...i?e:n].map(((e,n,t)=>{const i=t.findIndex((n=>n.name.value===e.name.value));if(i!==n){const n=t[i];return e.arguments=Fe(e.arguments,n.arguments),null}return e})).filter(m);for(const r of o)if(Me(s,r)){const e=s.findIndex((e=>e.name.value===r.name.value)),n=s[e];s[e].arguments=Fe(r.arguments||[],n.arguments||[])}else s.push(r);return s}function Re(e,n){return n?(function(e,n){const t=(0,Oe.S)({...e,description:void 0}),i=(0,Oe.S)({...n,description:void 0}),o=new RegExp("(directive @w*d*)|( on .*$)","g");if(t.replace(o,"")!==i.replace(o,""))throw new Error(`Unable to merge GraphQL directive "${e.name.value}". \nExisting directive:  \n\t${i} \nReceived directive: \n\t${t}`)}(e,n),{...e,locations:[...n.locations,...e.locations.filter((e=>!function(e,n){return n.some((({value:n})=>n===e.value))}(e,n.locations)))]}):e}function xe(e,n,t){return e.concat(n.filter((n=>t(n,e))))}function Ce(e,n,t){if(null==t?void 0:t.consistentEnumMerge){const t=[];e&&t.push(...e),e=n,n=t}const i=new Map;if(e)for(const s of e)i.set(s.name.value,s);if(n)for(const s of n){const e=s.name.value;if(i.has(e)){const n=i.get(e);n.description=s.description||n.description,n.directives=ke(s.directives,n.directives)}else i.set(e,s)}const o=[...i.values()];return t&&t.sort&&o.sort(E),o}function Pe(e,n,t){return n?{name:e.name,description:e.description||n.description,kind:t&&t.convertExtensions||"EnumTypeDefinition"===e.kind||"EnumTypeDefinition"===n.kind?"EnumTypeDefinition":"EnumTypeExtension",loc:e.loc,directives:ke(e.directives,n.directives,t),values:Ce(e.values,n.values,t)}:t&&t.convertExtensions?{...e,kind:"EnumTypeDefinition"}:e}function Ue(e){let n=e;for(;n.kind===l.h.LIST_TYPE||"NonNullType"===n.kind;)n=n.type;return n}function we(e){return e.kind!==l.h.NAMED_TYPE}function Le(e){return e.kind===l.h.LIST_TYPE}function Ye(e){return e.kind===l.h.NON_NULL_TYPE}function je(e){return Le(e)?`[${je(e.type)}]`:Ye(e)?`${je(e.type)}!`:e.name.value}function Be(e,n){return null==e&&null==n?_e.A_EQUALS_B:null==e?_e.A_SMALLER_THAN_B:null==n?_e.A_GREATER_THAN_B:e<n?_e.A_SMALLER_THAN_B:e>n?_e.A_GREATER_THAN_B:_e.A_EQUALS_B}function Ve(e,n,t){const i=e.find((e=>e.name.value===n.name.value));if(i&&!(null==t?void 0:t.ignoreFieldConflicts)){const e=Ue(i.type),t=Ue(n.type);if(e.name.value!==t.name.value)throw new Error(`Field "${n.name.value}" already defined with a different type. Declared as "${e.name.value}", but you tried to override with "${t.name.value}"`)}return!!i}function $e(e,n,t,i){const o=[];if(null!=t&&o.push(...t),null!=n)for(const s of n)if(Ve(o,s,i)){const n=o.find((e=>e.name.value===s.name.value));(null==i?void 0:i.ignoreFieldConflicts)||((null==i?void 0:i.throwOnConflict)?Ke(e,n,s,!1):Ke(e,n,s,!0),Ye(s.type)&&!Ye(n.type)&&(n.type=s.type)),n.arguments=be(s.arguments||[],n.arguments||[],i),n.directives=ke(s.directives,n.directives,i),n.description=s.description||n.description}else o.push(s);if(i&&i.sort&&o.sort(E),i&&i.exclusions){const n=i.exclusions;return o.filter((t=>!n.includes(`${e.name.value}.${t.name.value}`)))}return o}function Ke(e,n,t,i=!1){const o=je(n.type),s=je(t.type);if(v(o,s)&&!1===Je(n.type,t.type,i))throw new Error(`Field '${e.name.value}.${n.name.value}' changed type from '${o}' to '${s}'`)}function Je(e,n,t=!1){if(!we(e)&&!we(n))return e.toString()===n.toString();if(Ye(n)){return Je(Ye(e)?e.type:e,n.type)}return Ye(e)?Je(n,e,t):!!Le(e)&&(Le(n)&&Je(e.type,n.type)||Ye(n)&&Je(e,n.type))}function Ge(e,n,t){if(n)try{return{name:e.name,description:e.description||n.description,kind:t&&t.convertExtensions||"InputObjectTypeDefinition"===e.kind||"InputObjectTypeDefinition"===n.kind?"InputObjectTypeDefinition":"InputObjectTypeExtension",loc:e.loc,fields:$e(e,e.fields,n.fields,t),directives:ke(e.directives,n.directives,t)}}catch(i){throw new Error(`Unable to merge GraphQL input type "${e.name.value}": ${i.message}`)}return t&&t.convertExtensions?{...e,kind:"InputObjectTypeDefinition"}:e}function We(e,n,t){if(n)try{return{name:e.name,description:e.description||n.description,kind:t&&t.convertExtensions||"InterfaceTypeDefinition"===e.kind||"InterfaceTypeDefinition"===n.kind?"InterfaceTypeDefinition":"InterfaceTypeExtension",loc:e.loc,fields:$e(e,e.fields,n.fields,t),directives:ke(e.directives,n.directives,t)}}catch(i){throw new Error(`Unable to merge GraphQL interface "${e.name.value}": ${i.message}`)}return t&&t.convertExtensions?{...e,kind:"InterfaceTypeDefinition"}:e}function He(e=[],n=[],t={}){const i=[...n,...e.filter((e=>{return t=e,!n.find((e=>e.name.value===t.name.value));var t}))];return t&&t.sort&&i.sort(E),i}function Qe(e,n,t){if(n)try{return{name:e.name,description:e.description||n.description,kind:t&&t.convertExtensions||"ObjectTypeDefinition"===e.kind||"ObjectTypeDefinition"===n.kind?"ObjectTypeDefinition":"ObjectTypeExtension",loc:e.loc,fields:$e(e,e.fields,n.fields,t),directives:ke(e.directives,n.directives,t),interfaces:He(e.interfaces,n.interfaces,t)}}catch(i){throw new Error(`Unable to merge GraphQL type "${e.name.value}": ${i.message}`)}return t&&t.convertExtensions?{...e,kind:"ObjectTypeDefinition"}:e}function qe(e,n,t){return n?{name:e.name,description:e.description||n.description,kind:t&&t.convertExtensions||"ScalarTypeDefinition"===e.kind||"ScalarTypeDefinition"===n.kind?"ScalarTypeDefinition":"ScalarTypeExtension",loc:e.loc,directives:ke(e.directives,n.directives,t)}:t&&t.convertExtensions?{...e,kind:"ScalarTypeDefinition"}:e}function Xe(e,n,t){return n?{name:e.name,description:e.description||n.description,directives:ke(e.directives,n.directives,t),kind:t&&t.convertExtensions||"UnionTypeDefinition"===e.kind||"UnionTypeDefinition"===n.kind?"UnionTypeDefinition":"UnionTypeExtension",loc:e.loc,types:He(e.types,n.types,t)}:t&&t.convertExtensions?{...e,kind:"UnionTypeDefinition"}:e}!function(e){e[e.A_SMALLER_THAN_B=-1]="A_SMALLER_THAN_B",e[e.A_EQUALS_B=0]="A_EQUALS_B",e[e.A_GREATER_THAN_B=1]="A_GREATER_THAN_B"}(_e||(_e={}));const Ze={query:"Query",mutation:"Mutation",subscription:"Subscription"};function ze(e=[],n=[]){const t=[];for(const i in Ze){const o=e.find((e=>e.operation===i))||n.find((e=>e.operation===i));o&&t.push(o)}return t}function en(e,n,t){return n?{kind:e.kind===l.h.SCHEMA_DEFINITION||n.kind===l.h.SCHEMA_DEFINITION?l.h.SCHEMA_DEFINITION:l.h.SCHEMA_EXTENSION,description:e.description||n.description,directives:ke(e.directives,n.directives,t),operationTypes:ze(e.operationTypes,n.operationTypes)}:(null==t?void 0:t.convertExtensions)?{...e,kind:l.h.SCHEMA_EXTENSION}:e}const nn="SCHEMA_DEF_SYMBOL";function tn(e,n){ue();const t={kind:l.h.DOCUMENT,definitions:sn(e,{useSchemaDefinition:!0,forceSchemaDefinition:!1,throwOnConflict:!1,commentDescriptions:!1,...n})};let i;var o;return n&&n.commentDescriptions?(o=t,i=(0,f.Vn)(o,Ie)):i=t,ue(),i}function on(e,n,t=[],i=new Set){if(e&&!i.has(e))if(i.add(e),"function"==typeof e)on(e(),n,t,i);else if(Array.isArray(e))for(const o of e)on(o,n,t,i);else if((0,o.nN)(e)){on(_(e,n).definitions,n,t,i)}else if("string"==typeof e||function(e){return e instanceof ge.H}(e)){on((0,Ae.Qc)(e,n).definitions,n,t,i)}else if("object"==typeof e&&(0,De.Ir)(e))t.push(e);else{if(!(s=e)||"object"!=typeof s||!("kind"in s)||s.kind!==l.h.DOCUMENT)throw new Error("typeDefs must contain only strings, documents, schemas, or functions, got "+typeof e);on(e.definitions,n,t,i)}var s;return t}function sn(e,n){var t,i,o;ue();const s=function(e,n){var t,i,o;const s={};for(const r of e)if("name"in r){const e=null===(t=r.name)||void 0===t?void 0:t.value;if((null==n?void 0:n.commentDescriptions)&&de(r),null==e)continue;if((null===(i=null==n?void 0:n.exclusions)||void 0===i?void 0:i.includes(e+".*"))||(null===(o=null==n?void 0:n.exclusions)||void 0===o?void 0:o.includes(e)))delete s[e];else switch(r.kind){case l.h.OBJECT_TYPE_DEFINITION:case l.h.OBJECT_TYPE_EXTENSION:s[e]=Qe(r,s[e],n);break;case l.h.ENUM_TYPE_DEFINITION:case l.h.ENUM_TYPE_EXTENSION:s[e]=Pe(r,s[e],n);break;case l.h.UNION_TYPE_DEFINITION:case l.h.UNION_TYPE_EXTENSION:s[e]=Xe(r,s[e],n);break;case l.h.SCALAR_TYPE_DEFINITION:case l.h.SCALAR_TYPE_EXTENSION:s[e]=qe(r,s[e],n);break;case l.h.INPUT_OBJECT_TYPE_DEFINITION:case l.h.INPUT_OBJECT_TYPE_EXTENSION:s[e]=Ge(r,s[e],n);break;case l.h.INTERFACE_TYPE_DEFINITION:case l.h.INTERFACE_TYPE_EXTENSION:s[e]=We(r,s[e],n);break;case l.h.DIRECTIVE_DEFINITION:s[e]=Re(r,s[e])}}else r.kind!==l.h.SCHEMA_DEFINITION&&r.kind!==l.h.SCHEMA_EXTENSION||(s[nn]=en(r,s[nn],n));return s}(on(e,n),n);if(null==n?void 0:n.useSchemaDefinition){const e=s[nn]||{kind:l.h.SCHEMA_DEFINITION,operationTypes:[]},n=e.operationTypes;for(const t in Ze){if(!n.find((e=>e.operation===t))){const e=s[Ze[t]];null!=e&&null!=e.name&&n.push({kind:l.h.OPERATION_TYPE_DEFINITION,type:{kind:l.h.NAMED_TYPE,name:e.name},operation:t})}}null!=(null===(t=null==e?void 0:e.operationTypes)||void 0===t?void 0:t.length)&&e.operationTypes.length>0&&(s[nn]=e)}(null==n?void 0:n.forceSchemaDefinition)&&!(null===(o=null===(i=s[nn])||void 0===i?void 0:i.operationTypes)||void 0===o?void 0:o.length)&&(s[nn]={kind:l.h.SCHEMA_DEFINITION,operationTypes:[{kind:l.h.OPERATION_TYPE_DEFINITION,operation:"query",type:{kind:l.h.NAMED_TYPE,name:{kind:l.h.NAME,value:"Query"}}}]});const r=Object.values(s);if(null==n?void 0:n.sort){const e="function"==typeof n.sort?n.sort:Be;r.sort(((n,t)=>{var i,o;return e(null===(i=n.name)||void 0===i?void 0:i.value,null===(o=t.name)||void 0===o?void 0:o.value)}))}return r}function rn(e,n){e&&(e.extensions=le([e.extensions||{},n||{}]))}function ln(e){const n={schemaExtensions:{},types:{}};return function(e,n){n.onSchema(e);const t=e.getTypeMap();for(const[,o]of Object.entries(t)){const e=(0,i.KA)(o)&&(0,s.u1)(o),t=(0,c.s9)(o);if(!e&&!t)if((0,i.lp)(o)){n.onObjectType(o);const e=o.getFields();for(const[,t]of Object.entries(e)){n.onObjectField(o,t);const e=t.args||[];for(const i of e)n.onObjectFieldArg(o,t,i)}}else if((0,i.oT)(o)){n.onInterface(o);const e=o.getFields();for(const[,t]of Object.entries(e)){n.onInterfaceField(o,t);const e=t.args||[];for(const i of e)n.onInterfaceFieldArg(o,t,i)}}else if((0,i.hL)(o)){n.onInputType(o);const e=o.getFields();for(const[,t]of Object.entries(e))n.onInputFieldType(o,t)}else if((0,i.EN)(o))n.onUnion(o);else if((0,i.KA)(o))n.onScalar(o);else if((0,i.EM)(o)){n.onEnum(o);for(const e of o.getValues())n.onEnumValue(o,e)}}}(e,{onSchema:e=>n.schemaExtensions=e.extensions||{},onObjectType:e=>n.types[e.name]={fields:{},type:"object",extensions:e.extensions||{}},onObjectField:(e,t)=>n.types[e.name].fields[t.name]={arguments:{},extensions:t.extensions||{}},onObjectFieldArg:(e,t,i)=>n.types[e.name].fields[t.name].arguments[i.name]=i.extensions||{},onInterface:e=>n.types[e.name]={fields:{},type:"interface",extensions:e.extensions||{}},onInterfaceField:(e,t)=>n.types[e.name].fields[t.name]={arguments:{},extensions:t.extensions||{}},onInterfaceFieldArg:(e,t,i)=>n.types[e.name].fields[t.name].arguments[i.name]=i.extensions||{},onEnum:e=>n.types[e.name]={values:{},type:"enum",extensions:e.extensions||{}},onEnumValue:(e,t)=>n.types[e.name].values[t.name]=t.extensions||{},onScalar:e=>n.types[e.name]={type:"scalar",extensions:e.extensions||{}},onUnion:e=>n.types[e.name]={type:"union",extensions:e.extensions||{}},onInputType:e=>n.types[e.name]={fields:{},type:"input",extensions:e.extensions||{}},onInputFieldType:(e,t)=>n.types[e.name].fields[t.name]={extensions:t.extensions||{}}}),n}var an=t(30138);function cn(e,n,t,i,o){if(t.resolve){if("function"!=typeof t.resolve)throw new Error(`Resolver "${i}.${o}" must be a function`)}else{const t=`Resolver missing for "${i}.${o}".\nTo disable this validator, use:\n  resolverValidationOptions: {\n    ${e}: 'ignore'\n  }`;if("error"===n)throw new Error(t);"warn"===n&&an.warn(t)}}function un(e,n,t){const r=(0,o.nN)(e)?{schema:e,resolvers:null!=n?n:{},resolverValidationOptions:t}:e;let{schema:l,resolvers:a,defaultFieldResolver:c,resolverValidationOptions:u={},inheritResolversFromInterfaces:d=!1,updateResolversInPlace:f=!1}=r;const{requireResolversToMatchSchema:p="error",requireResolversForResolveType:v}=u,T=d?function(e,n){const t={},i=e.getTypeMap();for(const o in i){const e=i[o];if("getInterfaces"in e){t[o]={};for(const s of e.getInterfaces())if(n[s.name])for(const e in n[s.name])"__isTypeOf"!==e&&e.startsWith("__")||(t[o][e]=n[s.name][e]);const i=n[o];t[o]={...t[o],...i}}else{const e=n[o];null!=e&&(t[o]=e)}}return t}(l,a):a;for(const o in T){const e=T[o];if("object"!==typeof e)throw new Error(`"${o}" defined in resolvers, but has invalid value "${e}". The resolver's value must be of type object.`);const n=l.getType(o);if(null==n){if("ignore"===p)break;throw new Error(`"${o}" defined in resolvers, but not in schema`)}if((0,s.u1)(n))for(const t in e)t.startsWith("__")?n[t.substring(2)]=e[t]:n[t]=e[t];else if((0,i.EM)(n)){const t=n.getValues();for(const i in e)if(!i.startsWith("__")&&!t.some((e=>e.name===i))&&p&&"ignore"!==p)throw new Error(`${n.name}.${i} was defined in resolvers, but not present within ${n.name}`)}else if((0,i.EN)(n)){for(const t in e)if(!t.startsWith("__")&&p&&"ignore"!==p)throw new Error(`${n.name}.${t} was defined in resolvers, but ${n.name} is not an object or interface type`)}else if((0,i.lp)(n)||(0,i.oT)(n))for(const t in e)if(!t.startsWith("__")){if(null==n.getFields()[t]){if(p&&"ignore"!==p)throw new Error(`${o}.${t} defined in resolvers, but not in schema`)}else{const n=e[t];if("function"!=typeof n&&"object"!=typeof n)throw new Error(`Resolver ${o}.${t} must be object or function`)}}}return l=f?function(e,n,t){var o,s,r,l,a,c,u,d,f,p,v,T,E,m,y,N,I,h;const _=e.getTypeMap();for(const O in n){const t=e.getType(O),g=n[O];if((0,i.KA)(t))for(const e in g)e.startsWith("__")?t[e.substring(2)]=g[e]:"astNode"===e&&null!=t.astNode?t.astNode={...t.astNode,description:null!==(r=null===(s=null===(o=g)||void 0===o?void 0:o.astNode)||void 0===s?void 0:s.description)&&void 0!==r?r:t.astNode.description,directives:(null!==(l=t.astNode.directives)&&void 0!==l?l:[]).concat(null!==(u=null===(c=null===(a=g)||void 0===a?void 0:a.astNode)||void 0===c?void 0:c.directives)&&void 0!==u?u:[])}:"extensionASTNodes"===e&&null!=t.extensionASTNodes?t.extensionASTNodes=t.extensionASTNodes.concat(null!==(f=null===(d=g)||void 0===d?void 0:d.extensionASTNodes)&&void 0!==f?f:[]):"extensions"===e&&null!=t.extensions&&null!=g.extensions?t.extensions=Object.assign({},t.extensions,g.extensions):t[e]=g[e];else if((0,i.EM)(t)){const e=t.toConfig(),n=e.values;for(const i in g)i.startsWith("__")?e[i.substring(2)]=g[i]:"astNode"===i&&null!=e.astNode?e.astNode={...e.astNode,description:null!==(T=null===(v=null===(p=g)||void 0===p?void 0:p.astNode)||void 0===v?void 0:v.description)&&void 0!==T?T:e.astNode.description,directives:(null!==(E=e.astNode.directives)&&void 0!==E?E:[]).concat(null!==(N=null===(y=null===(m=g)||void 0===m?void 0:m.astNode)||void 0===y?void 0:y.directives)&&void 0!==N?N:[])}:"extensionASTNodes"===i&&null!=e.extensionASTNodes?e.extensionASTNodes=e.extensionASTNodes.concat(null!==(h=null===(I=g)||void 0===I?void 0:I.extensionASTNodes)&&void 0!==h?h:[]):"extensions"===i&&null!=t.extensions&&null!=g.extensions?t.extensions=Object.assign({},t.extensions,g.extensions):n[i]&&(n[i].value=g[i]);_[O]=new i.mR(e)}else if((0,i.EN)(t))for(const e in g)e.startsWith("__")&&(t[e.substring(2)]=g[e]);else if((0,i.lp)(t)||(0,i.oT)(t))for(const e in g){if(e.startsWith("__")){t[e.substring(2)]=g[e];break}const n=t.getFields()[e];if(null!=n){const t=g[e];"function"==typeof t?n.resolve=t.bind(g):dn(n,t)}}}te(e,B),z(e),te(e,V),null!=t&&ne(e,(e=>{e.resolve||(e.resolve=t)}));return e}(l,T,c):function(e,n,t){e=$(e,{[w.SCALAR_TYPE]:e=>{var t,o,r,l,a,c,u,d,f;const p=e.toConfig(),v=n[e.name];if(!(0,s.u1)(e)&&null!=v){for(const n in v)n.startsWith("__")?p[n.substring(2)]=v[n]:"astNode"===n&&null!=p.astNode?p.astNode={...p.astNode,description:null!==(r=null===(o=null===(t=v)||void 0===t?void 0:t.astNode)||void 0===o?void 0:o.description)&&void 0!==r?r:p.astNode.description,directives:(null!==(l=p.astNode.directives)&&void 0!==l?l:[]).concat(null!==(u=null===(c=null===(a=v)||void 0===a?void 0:a.astNode)||void 0===c?void 0:c.directives)&&void 0!==u?u:[])}:"extensionASTNodes"===n&&null!=p.extensionASTNodes?p.extensionASTNodes=p.extensionASTNodes.concat(null!==(f=null===(d=v)||void 0===d?void 0:d.extensionASTNodes)&&void 0!==f?f:[]):"extensions"===n&&null!=p.extensions&&null!=v.extensions?p.extensions=Object.assign({},e.extensions,v.extensions):p[n]=v[n];return new i.n2(p)}},[w.ENUM_TYPE]:e=>{var t,o,s,r,l,a,c,u,d;const f=n[e.name],p=e.toConfig(),v=p.values;if(null!=f){for(const n in f)n.startsWith("__")?p[n.substring(2)]=f[n]:"astNode"===n&&null!=p.astNode?p.astNode={...p.astNode,description:null!==(s=null===(o=null===(t=f)||void 0===t?void 0:t.astNode)||void 0===o?void 0:o.description)&&void 0!==s?s:p.astNode.description,directives:(null!==(r=p.astNode.directives)&&void 0!==r?r:[]).concat(null!==(c=null===(a=null===(l=f)||void 0===l?void 0:l.astNode)||void 0===a?void 0:a.directives)&&void 0!==c?c:[])}:"extensionASTNodes"===n&&null!=p.extensionASTNodes?p.extensionASTNodes=p.extensionASTNodes.concat(null!==(d=null===(u=f)||void 0===u?void 0:u.extensionASTNodes)&&void 0!==d?d:[]):"extensions"===n&&null!=p.extensions&&null!=f.extensions?p.extensions=Object.assign({},e.extensions,f.extensions):v[n]&&(v[n].value=f[n]);return new i.mR(p)}},[w.UNION_TYPE]:e=>{const t=n[e.name];if(null!=t){const n=e.toConfig();return t.__resolveType&&(n.resolveType=t.__resolveType),new i.Gp(n)}},[w.OBJECT_TYPE]:e=>{const t=n[e.name];if(null!=t){const n=e.toConfig();return t.__isTypeOf&&(n.isTypeOf=t.__isTypeOf),new i.h6(n)}},[w.INTERFACE_TYPE]:e=>{const t=n[e.name];if(null!=t){const n=e.toConfig();return t.__resolveType&&(n.resolveType=t.__resolveType),new i.oW(n)}},[w.COMPOSITE_FIELD]:(e,t,i)=>{const o=n[i];if(null!=o){const n=o[t];if(null!=n){const t={...e};return"function"==typeof n?t.resolve=n.bind(o):dn(t,n),t}}}}),null!=t&&(e=$(e,{[w.OBJECT_FIELD]:e=>({...e,resolve:null!=e.resolve?e.resolve:t})}));return e}(l,T,c),v&&"ignore"!==v&&function(e,n){$(e,{[w.ABSTRACT_TYPE]:e=>{if(!e.resolveType){const t=`Type "${e.name}" is missing a "__resolveType" resolver. Pass 'ignore' into "resolverValidationOptions.requireResolversForResolveType" to disable this error.`;if("error"===n)throw new Error(t);"warn"===n&&an.warn(t)}}})}(l,v),l}function dn(e,n){for(const t in n)e[t]=n[t]}function fn({typeDefs:e,resolvers:n={},resolverValidationOptions:t={},parseOptions:s={},inheritResolversFromInterfaces:l=!1,pruningOptions:a,updateResolversInPlace:c=!1,schemaExtensions:u}){if("object"!=typeof t)throw new Error("Expected `resolverValidationOptions` to be an object");if(!e)throw new Error("Must provide typeDefs");let d;if((0,o.nN)(e))d=e;else if(null==s?void 0:s.commentDescriptions){const n=tn(e,{...s,commentDescriptions:!0});d=(0,r.I)(n,s)}else{const n=tn(e,s);d=(0,r.M)(n,s)}return a&&(d=ie(d)),d=un({schema:d,resolvers:Se(n),resolverValidationOptions:t,inheritResolversFromInterfaces:l,updateResolversInPlace:c}),Object.keys(t).length>0&&function(e,n={}){const{requireResolversForArgs:t,requireResolversForNonScalar:o,requireResolversForAllFields:s}=n;if(s&&(t||o))throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");ne(e,((e,n,r)=>{s&&cn("requireResolversForAllFields",s,e,n,r),t&&e.args.length>0&&cn("requireResolversForArgs",t,e,n,r),"ignore"===o||(0,i.KA)((0,i.xC)(e.type))||cn("requireResolversForNonScalar",o,e,n,r)}))}(d,t),u&&function(e,n){rn(e,n.schemaExtensions);for(const[t,i]of Object.entries(n.types||{})){const n=e.getType(t);if(n)if(rn(n,i.extensions),"object"===i.type||"interface"===i.type)for(const[e,t]of Object.entries(i.fields)){const i=n.getFields()[e];if(i){rn(i,t.extensions);for(const[e,n]of Object.entries(t.arguments))rn(i.args.find((n=>n.name===e)),n)}}else if("input"===i.type)for(const[e,t]of Object.entries(i.fields))rn(n.getFields()[e],t.extensions);else if("enum"===i.type)for(const[e,t]of Object.entries(i.values))rn(n.getValue(e),t)}}(d,u=le(p(u))),d}function pn(e){const n=p(e.typeDefs||[]),t=p(e.resolvers||[]),i=p(e.schemaExtensions||[]),o=e.schemas||[];for(const s of o)n.push(s),t.push(ee(s)),i.push(ln(s));return fn({parseOptions:e,...e,typeDefs:n,resolvers:t,schemaExtensions:i})}},62544:function(e,n,t){t.d(n,{sF:function(){return c},OV:function(){return a}});var i=t(57554),o=t(15635),s=t(59047),r=t(49159);let l=globalThis.AggregateError;if(void 0===l){class e extends Error{constructor(n,t=""){super(t),this.errors=n,this.name="AggregateError",Error.captureStackTrace(this,e)}}l=function(n,t){return new e(n,t)}}async function a(e,n,t){t=t||function(){const e=["NoUnusedFragmentsRule","NoUnusedVariablesRule","KnownDirectivesRule"],n=e.map((e=>e.replace(/Rule$/,"")));return r.i.filter((t=>!e.includes(t.name)&&!n.includes(t.name)))}();const l=new Map,a=[];for(const o of n)if(o.document){const e=[];for(const n of o.document.definitions)n.kind===i.h.FRAGMENT_DEFINITION?l.set(n.name.value,n):e.push(n);a.push({location:o.location,document:{kind:i.h.DOCUMENT,definitions:e}})}const c=[],u={kind:i.h.DOCUMENT,definitions:[...l.values()]};return await Promise.all(a.map((async n=>{const i=(0,o.n)([u,n.document]),r=(0,s.Gu)(e,i,t);r.length>0&&c.push({filePath:n.location,errors:r})}))),c}function c(e){if(e.length>0){const n=[];for(const t of e)for(const e of t.errors){const i=new Error;if(i.name="GraphQLDocumentError",i.message=`${i.name}: ${e.message}`,i.stack=i.message,e.locations)for(const n of e.locations)i.stack+=`\n    at ${t.filePath}:${n.line}:${n.column}`;n.push(i)}throw new l(n,`GraphQL Document Validation failed with ${n.length} errors;\n  ${n.map(((e,n)=>`Error ${n}: ${e.stack}`)).join("\n\n")}`)}}new Map;var u;!function(e){e.TYPE="MapperKind.TYPE",e.SCALAR_TYPE="MapperKind.SCALAR_TYPE",e.ENUM_TYPE="MapperKind.ENUM_TYPE",e.COMPOSITE_TYPE="MapperKind.COMPOSITE_TYPE",e.OBJECT_TYPE="MapperKind.OBJECT_TYPE",e.INPUT_OBJECT_TYPE="MapperKind.INPUT_OBJECT_TYPE",e.ABSTRACT_TYPE="MapperKind.ABSTRACT_TYPE",e.UNION_TYPE="MapperKind.UNION_TYPE",e.INTERFACE_TYPE="MapperKind.INTERFACE_TYPE",e.ROOT_OBJECT="MapperKind.ROOT_OBJECT",e.QUERY="MapperKind.QUERY",e.MUTATION="MapperKind.MUTATION",e.SUBSCRIPTION="MapperKind.SUBSCRIPTION",e.DIRECTIVE="MapperKind.DIRECTIVE",e.FIELD="MapperKind.FIELD",e.COMPOSITE_FIELD="MapperKind.COMPOSITE_FIELD",e.OBJECT_FIELD="MapperKind.OBJECT_FIELD",e.ROOT_FIELD="MapperKind.ROOT_FIELD",e.QUERY_ROOT_FIELD="MapperKind.QUERY_ROOT_FIELD",e.MUTATION_ROOT_FIELD="MapperKind.MUTATION_ROOT_FIELD",e.SUBSCRIPTION_ROOT_FIELD="MapperKind.SUBSCRIPTION_ROOT_FIELD",e.INTERFACE_FIELD="MapperKind.INTERFACE_FIELD",e.INPUT_OBJECT_FIELD="MapperKind.INPUT_OBJECT_FIELD",e.ARGUMENT="MapperKind.ARGUMENT",e.ENUM_VALUE="MapperKind.ENUM_VALUE"}(u||(u={}));let d={};function f(e){return"\n# "+e.replace(/\n/g,"\n# ")}function p(e,n){return e?e.filter((e=>e)).join(n||""):""}function v(e){var n;return null!==(n=null==e?void 0:e.some((e=>e.includes("\n"))))&&void 0!==n&&n}function T(e){return e&&`  ${e.replace(/\n/g,"\n  ")}`}function E(e){return e&&0!==e.length?`{\n${T(p(e,"\n"))}\n}`:""}function m(e,n,t){return n?e+n+(t||""):""}const y={Name:{leave:e=>e.value},Variable:{leave:e=>"$"+e.name},Document:{leave:e=>p(e.definitions,"\n\n")},OperationDefinition:{leave:e=>{const n=m("(",p(e.variableDefinitions,", "),")");return p([e.operation,p([e.name,n]),p(e.directives," ")]," ")+" "+e.selectionSet}},VariableDefinition:{leave:({variable:e,type:n,defaultValue:t,directives:i})=>e+": "+n+m(" = ",t)+m(" ",p(i," "))},SelectionSet:{leave:({selections:e})=>E(e)},Field:{leave({alias:e,name:n,arguments:t,directives:i,selectionSet:o}){const s=m("",e,": ")+n;let r=s+m("(",p(t,", "),")");return r.length>80&&(r=s+m("(\n",T(p(t,"\n")),"\n)")),p([r,p(i," "),o]," ")}},Argument:{leave:({name:e,value:n})=>e+": "+n},FragmentSpread:{leave:({name:e,directives:n})=>"..."+e+m(" ",p(n," "))},InlineFragment:{leave:({typeCondition:e,directives:n,selectionSet:t})=>p(["...",m("on ",e),p(n," "),t]," ")},FragmentDefinition:{leave:({name:e,typeCondition:n,variableDefinitions:t,directives:i,selectionSet:o})=>`fragment ${e}${m("(",p(t,", "),")")} on ${n} ${m("",p(i," ")," ")}`+o},IntValue:{leave:({value:e})=>e},FloatValue:{leave:({value:e})=>e},StringValue:{leave:({value:e,block:n})=>n?function(e,n=!1){const t=e.replace(/"""/g,'\\"""');return" "!==e[0]&&"\t"!==e[0]||-1!==e.indexOf("\n")?`"""\n${n?t:T(t)}\n"""`:`"""${t.replace(/"$/,'"\n')}"""`}(e):JSON.stringify(e)},BooleanValue:{leave:({value:e})=>e?"true":"false"},NullValue:{leave:()=>"null"},EnumValue:{leave:({value:e})=>e},ListValue:{leave:({values:e})=>"["+p(e,", ")+"]"},ObjectValue:{leave:({fields:e})=>"{"+p(e,", ")+"}"},ObjectField:{leave:({name:e,value:n})=>e+": "+n},Directive:{leave:({name:e,arguments:n})=>"@"+e+m("(",p(n,", "),")")},NamedType:{leave:({name:e})=>e},ListType:{leave:({type:e})=>"["+e+"]"},NonNullType:{leave:({type:e})=>e+"!"},SchemaDefinition:{leave:({description:e,directives:n,operationTypes:t})=>m("",e,"\n")+p(["schema",p(n," "),E(t)]," ")},OperationTypeDefinition:{leave:({operation:e,type:n})=>e+": "+n},ScalarTypeDefinition:{leave:({description:e,name:n,directives:t})=>m("",e,"\n")+p(["scalar",n,p(t," ")]," ")},ObjectTypeDefinition:{leave:({description:e,name:n,interfaces:t,directives:i,fields:o})=>m("",e,"\n")+p(["type",n,m("implements ",p(t," & ")),p(i," "),E(o)]," ")},FieldDefinition:{leave:({description:e,name:n,arguments:t,type:i,directives:o})=>m("",e,"\n")+n+(v(t)?m("(\n",T(p(t,"\n")),"\n)"):m("(",p(t,", "),")"))+": "+i+m(" ",p(o," "))},InputValueDefinition:{leave:({description:e,name:n,type:t,defaultValue:i,directives:o})=>m("",e,"\n")+p([n+": "+t,m("= ",i),p(o," ")]," ")},InterfaceTypeDefinition:{leave:({description:e,name:n,interfaces:t,directives:i,fields:o})=>m("",e,"\n")+p(["interface",n,m("implements ",p(t," & ")),p(i," "),E(o)]," ")},UnionTypeDefinition:{leave:({description:e,name:n,directives:t,types:i})=>m("",e,"\n")+p(["union",n,p(t," "),m("= ",p(i," | "))]," ")},EnumTypeDefinition:{leave:({description:e,name:n,directives:t,values:i})=>m("",e,"\n")+p(["enum",n,p(t," "),E(i)]," ")},EnumValueDefinition:{leave:({description:e,name:n,directives:t})=>m("",e,"\n")+p([n,p(t," ")]," ")},InputObjectTypeDefinition:{leave:({description:e,name:n,directives:t,fields:i})=>m("",e,"\n")+p(["input",n,p(t," "),E(i)]," ")},DirectiveDefinition:{leave:({description:e,name:n,arguments:t,repeatable:i,locations:o})=>m("",e,"\n")+"directive @"+n+(v(t)?m("(\n",T(p(t,"\n")),"\n)"):m("(",p(t,", "),")"))+(i?" repeatable":"")+" on "+p(o," | ")},SchemaExtension:{leave:({directives:e,operationTypes:n})=>p(["extend schema",p(e," "),E(n)]," ")},ScalarTypeExtension:{leave:({name:e,directives:n})=>p(["extend scalar",e,p(n," ")]," ")},ObjectTypeExtension:{leave:({name:e,interfaces:n,directives:t,fields:i})=>p(["extend type",e,m("implements ",p(n," & ")),p(t," "),E(i)]," ")},InterfaceTypeExtension:{leave:({name:e,interfaces:n,directives:t,fields:i})=>p(["extend interface",e,m("implements ",p(n," & ")),p(t," "),E(i)]," ")},UnionTypeExtension:{leave:({name:e,directives:n,types:t})=>p(["extend union",e,p(n," "),m("= ",p(t," | "))]," ")},EnumTypeExtension:{leave:({name:e,directives:n,values:t})=>p(["extend enum",e,p(n," "),E(t)]," ")},InputObjectTypeExtension:{leave:({name:e,directives:n,fields:t})=>p(["extend input",e,p(n," "),E(t)]," ")}};Object.keys(y).reduce(((e,n)=>{return{...e,[n]:{leave:(t=y[n].leave,(e,n,i,o,s)=>{var r;const l=[],a=o.reduce(((e,n)=>(["fields","arguments","values"].includes(n)&&e.name&&l.push(e.name.value),e[n])),s[0]),c=[...l,null===(r=null==a?void 0:a.name)||void 0===r?void 0:r.value].filter(Boolean).join("."),u=[];return e.kind.includes("Definition")&&d[c]&&u.push(...d[c]),p([...u.map(f),e.description,t(e)],"\n")})}};var t}),{})}}]);